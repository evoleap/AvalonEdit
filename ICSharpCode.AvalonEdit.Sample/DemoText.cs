using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AvalonEdit.Sample
{
	public static class DemoText
	{
		public static readonly string DemoText1 = "// Copyright (c) 2014 AlphaSierraPapa for the SharpDevelop Team\r\n// \r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n// software and associated documentation files (the \"Software\"), to deal in the Software\r\n// without restriction, including without limitation the rights to use, copy, modify, merge,\r\n// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\r\n// to whom the Software is furnished to do so, subject to the following conditions:\r\n// \r\n// The above copyright notice and this permission notice shall be included in all copies or\r\n// substantial portions of the Software.\r\n// \r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\r\n// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\r\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n// DEALINGS IN THE SOFTWARE.\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.ObjectModel;\r\nusing System.ComponentModel;\r\nusing System.ComponentModel.Design;\r\nusing System.Diagnostics;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Windows;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Controls.Primitives;\r\nusing System.Windows.Input;\r\nusing System.Windows.Media;\r\nusing System.Windows.Media.TextFormatting;\r\nusing System.Windows.Threading;\r\n\r\nusing ICSharpCode.AvalonEdit.Document;\r\nusing ICSharpCode.AvalonEdit.Utils;\r\n\r\nnamespace ICSharpCode.AvalonEdit.Rendering\r\n{\r\n\t/// <summary>\r\n\t/// A virtualizing panel producing+showing <see cref=\"VisualLine\"/>s for a <see cref=\"TextDocument\"/>.\r\n\t/// \r\n\t/// This is the heart of the text editor, this class controls the text rendering process.\r\n\t/// \r\n\t/// Taken as a standalone control, it's a text viewer without any editing capability.\r\n\t/// </summary>\r\n\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t Justification = \"The user usually doesn't work with TextView but with TextEditor; and nulling the Document property is sufficient to dispose everything.\")]\r\n\tpublic class TextView : FrameworkElement, IScrollInfo, IWeakEventListener, ITextEditorComponent, IServiceProvider\r\n\t{\r\n\t\t#region Constructor\r\n\t\tstatic TextView()\r\n\t\t{\r\n\t\t\tClipToBoundsProperty.OverrideMetadata(typeof(TextView), new FrameworkPropertyMetadata(Boxes.True));\r\n\t\t\tFocusableProperty.OverrideMetadata(typeof(TextView), new FrameworkPropertyMetadata(Boxes.False));\r\n\t\t}\r\n\r\n\t\tColumnRulerRenderer columnRulerRenderer;\r\n\t\tCurrentLineHighlightRenderer currentLineHighlighRenderer;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Creates a new TextView instance.\r\n\t\t/// </summary>\r\n\t\tpublic TextView()\r\n\t\t{\r\n\t\t\tservices.AddService(typeof(TextView), this);\r\n\t\t\ttextLayer = new TextLayer(this);\r\n\t\t\telementGenerators = new ObserveAddRemoveCollection<VisualLineElementGenerator>(ElementGenerator_Added, ElementGenerator_Removed);\r\n\t\t\tlineTransformers = new ObserveAddRemoveCollection<IVisualLineTransformer>(LineTransformer_Added, LineTransformer_Removed);\r\n\t\t\tbackgroundRenderers = new ObserveAddRemoveCollection<IBackgroundRenderer>(BackgroundRenderer_Added, BackgroundRenderer_Removed);\r\n\t\t\tcolumnRulerRenderer = new ColumnRulerRenderer(this);\r\n\t\t\tcurrentLineHighlighRenderer = new CurrentLineHighlightRenderer(this);\r\n\t\t\tthis.Options = new TextEditorOptions();\r\n\r\n\t\t\tDebug.Assert(singleCharacterElementGenerator != null); // assert that the option change created the builtin element generators\r\n\r\n\t\t\tlayers = new LayerCollection(this);\r\n\t\t\tInsertLayer(textLayer, KnownLayer.Text, LayerInsertionPosition.Replace);\r\n\r\n\t\t\tthis.hoverLogic = new MouseHoverLogic(this);\r\n\t\t\tthis.hoverLogic.MouseHover += (sender, e) => RaiseHoverEventPair(e, PreviewMouseHoverEvent, MouseHoverEvent);\r\n\t\t\tthis.hoverLogic.MouseHoverStopped += (sender, e) => RaiseHoverEventPair(e, PreviewMouseHoverStoppedEvent, MouseHoverStoppedEvent);\r\n\t\t}\r\n\r\n\t\t#endregion\r\n\r\n\t\t#region Document Property\r\n\t\t/// <summary>\r\n\t\t/// Document property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty DocumentProperty =\r\n\t\t\tDependencyProperty.Register(\"Document\", typeof(TextDocument), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(OnDocumentChanged));\r\n\r\n\t\tTextDocument document;\r\n\t\tHeightTree heightTree;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets the document displayed by the text editor.\r\n\t\t/// </summary>\r\n\t\tpublic TextDocument Document {\r\n\t\t\tget { return (TextDocument)GetValue(DocumentProperty); }\r\n\t\t\tset { SetValue(DocumentProperty, value); }\r\n\t\t}\r\n\r\n\t\tstatic void OnDocumentChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e)\r\n\t\t{\r\n\t\t\t((TextView)dp).OnDocumentChanged((TextDocument)e.OldValue, (TextDocument)e.NewValue);\r\n\t\t}\r\n\r\n\t\tinternal double FontSize {\r\n\t\t\tget {\r\n\t\t\t\treturn (double)GetValue(TextBlock.FontSizeProperty);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the document property has changed.\r\n\t\t/// </summary>\r\n\t\tpublic event EventHandler DocumentChanged;\r\n\r\n\t\tvoid OnDocumentChanged(TextDocument oldValue, TextDocument newValue)\r\n\t\t{\r\n\t\t\tif (oldValue != null) {\r\n\t\t\t\theightTree.Dispose();\r\n\t\t\t\theightTree = null;\r\n\t\t\t\tformatter.Dispose();\r\n\t\t\t\tformatter = null;\r\n\t\t\t\tcachedElements.Dispose();\r\n\t\t\t\tcachedElements = null;\r\n\t\t\t\tTextDocumentWeakEventManager.Changing.RemoveListener(oldValue, this);\r\n\t\t\t}\r\n\t\t\tthis.document = newValue;\r\n\t\t\tClearScrollData();\r\n\t\t\tClearVisualLines();\r\n\t\t\tif (newValue != null) {\r\n\t\t\t\tTextDocumentWeakEventManager.Changing.AddListener(newValue, this);\r\n\t\t\t\tformatter = TextFormatterFactory.Create(this);\r\n\t\t\t\tInvalidateDefaultTextMetrics(); // measuring DefaultLineHeight depends on formatter\r\n\t\t\t\theightTree = new HeightTree(newValue, DefaultLineHeight);\r\n\t\t\t\tcachedElements = new TextViewCachedElements();\r\n\t\t\t}\r\n\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\tif (DocumentChanged != null)\r\n\t\t\t\tDocumentChanged(this, EventArgs.Empty);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Recreates the text formatter that is used internally\r\n\t\t/// by calling <see cref=\"TextFormatterFactory.Create\"/>.\r\n\t\t/// </summary>\r\n\t\tvoid RecreateTextFormatter()\r\n\t\t{\r\n\t\t\tif (formatter != null) {\r\n\t\t\t\tformatter.Dispose();\r\n\t\t\t\tformatter = TextFormatterFactory.Create(this);\r\n\t\t\t\tRedraw();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid RecreateCachedElements()\r\n\t\t{\r\n\t\t\tif (cachedElements != null) {\r\n\t\t\t\tcachedElements.Dispose();\r\n\t\t\t\tcachedElements = new TextViewCachedElements();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc cref=\"IWeakEventListener.ReceiveWeakEvent\"/>\r\n\t\tprotected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e)\r\n\t\t{\r\n\t\t\tif (managerType == typeof(TextDocumentWeakEventManager.Changing)) {\r\n\t\t\t\t// TODO: put redraw into background so that other input events can be handled before the redraw.\r\n\t\t\t\t// Unfortunately the \"easy\" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because\r\n\t\t\t\t// the caret position change forces an immediate redraw, and the text input then forces a background redraw.\r\n\t\t\t\t// When fixing this, make sure performance on the SharpDevelop \"type text in C# comment\" stress test doesn't get significantly worse.\r\n\t\t\t\tDocumentChangeEventArgs change = (DocumentChangeEventArgs)e;\r\n\t\t\t\tRedraw(change.Offset, change.RemovalLength, DispatcherPriority.Normal);\r\n\t\t\t\treturn true;\r\n\t\t\t} else if (managerType == typeof(PropertyChangedWeakEventManager)) {\r\n\t\t\t\tOnOptionChanged((PropertyChangedEventArgs)e);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbool IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e)\r\n\t\t{\r\n\t\t\treturn ReceiveWeakEvent(managerType, sender, e);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Options property\r\n\t\t/// <summary>\r\n\t\t/// Options property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty OptionsProperty =\r\n\t\t\tDependencyProperty.Register(\"Options\", typeof(TextEditorOptions), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(OnOptionsChanged));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets the options used by the text editor.\r\n\t\t/// </summary>\r\n\t\tpublic TextEditorOptions Options {\r\n\t\t\tget { return (TextEditorOptions)GetValue(OptionsProperty); }\r\n\t\t\tset { SetValue(OptionsProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when a text editor option has changed.\r\n\t\t/// </summary>\r\n\t\tpublic event PropertyChangedEventHandler OptionChanged;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Raises the <see cref=\"OptionChanged\"/> event.\r\n\t\t/// </summary>\r\n\t\tprotected virtual void OnOptionChanged(PropertyChangedEventArgs e)\r\n\t\t{\r\n\t\t\tif (OptionChanged != null) {\r\n\t\t\t\tOptionChanged(this, e);\r\n\t\t\t}\r\n\r\n\t\t\tif (Options.ShowColumnRuler)\r\n\t\t\t\tcolumnRulerRenderer.SetRuler(Options.ColumnRulerPosition, ColumnRulerPen);\r\n\t\t\telse\r\n\t\t\t\tcolumnRulerRenderer.SetRuler(-1, ColumnRulerPen);\r\n\r\n\t\t\tUpdateBuiltinElementGeneratorsFromOptions();\r\n\t\t\tRedraw();\r\n\t\t}\r\n\r\n\t\tstatic void OnOptionsChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e)\r\n\t\t{\r\n\t\t\t((TextView)dp).OnOptionsChanged((TextEditorOptions)e.OldValue, (TextEditorOptions)e.NewValue);\r\n\t\t}\r\n\r\n\t\tvoid OnOptionsChanged(TextEditorOptions oldValue, TextEditorOptions newValue)\r\n\t\t{\r\n\t\t\tif (oldValue != null) {\r\n\t\t\t\tPropertyChangedWeakEventManager.RemoveListener(oldValue, this);\r\n\t\t\t}\r\n\t\t\tif (newValue != null) {\r\n\t\t\t\tPropertyChangedWeakEventManager.AddListener(newValue, this);\r\n\t\t\t}\r\n\t\t\tOnOptionChanged(new PropertyChangedEventArgs(null));\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region ElementGenerators+LineTransformers Properties\r\n\t\treadonly ObserveAddRemoveCollection<VisualLineElementGenerator> elementGenerators;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets a collection where element generators can be registered.\r\n\t\t/// </summary>\r\n\t\tpublic IList<VisualLineElementGenerator> ElementGenerators {\r\n\t\t\tget { return elementGenerators; }\r\n\t\t}\r\n\r\n\t\tvoid ElementGenerator_Added(VisualLineElementGenerator generator)\r\n\t\t{\r\n\t\t\tConnectToTextView(generator);\r\n\t\t\tRedraw();\r\n\t\t}\r\n\r\n\t\tvoid ElementGenerator_Removed(VisualLineElementGenerator generator)\r\n\t\t{\r\n\t\t\tDisconnectFromTextView(generator);\r\n\t\t\tRedraw();\r\n\t\t}\r\n\r\n\t\treadonly ObserveAddRemoveCollection<IVisualLineTransformer> lineTransformers;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets a collection where line transformers can be registered.\r\n\t\t/// </summary>\r\n\t\tpublic IList<IVisualLineTransformer> LineTransformers {\r\n\t\t\tget { return lineTransformers; }\r\n\t\t}\r\n\r\n\t\tvoid LineTransformer_Added(IVisualLineTransformer lineTransformer)\r\n\t\t{\r\n\t\t\tConnectToTextView(lineTransformer);\r\n\t\t\tRedraw();\r\n\t\t}\r\n\r\n\t\tvoid LineTransformer_Removed(IVisualLineTransformer lineTransformer)\r\n\t\t{\r\n\t\t\tDisconnectFromTextView(lineTransformer);\r\n\t\t\tRedraw();\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Builtin ElementGenerators\r\n\t\t//\t\tNewLineElementGenerator newLineElementGenerator;\r\n\t\tSingleCharacterElementGenerator singleCharacterElementGenerator;\r\n\t\tLinkElementGenerator linkElementGenerator;\r\n\t\tMailLinkElementGenerator mailLinkElementGenerator;\r\n\r\n\t\tvoid UpdateBuiltinElementGeneratorsFromOptions()\r\n\t\t{\r\n\t\t\tTextEditorOptions options = this.Options;\r\n\r\n\t\t\t//\t\t\tAddRemoveDefaultElementGeneratorOnDemand(ref newLineElementGenerator, options.ShowEndOfLine);\r\n\t\t\tAddRemoveDefaultElementGeneratorOnDemand(ref singleCharacterElementGenerator, options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs);\r\n\t\t\tAddRemoveDefaultElementGeneratorOnDemand(ref linkElementGenerator, options.EnableHyperlinks);\r\n\t\t\tAddRemoveDefaultElementGeneratorOnDemand(ref mailLinkElementGenerator, options.EnableEmailHyperlinks);\r\n\t\t}\r\n\r\n\t\tvoid AddRemoveDefaultElementGeneratorOnDemand<T>(ref T generator, bool demand)\r\n\t\t\twhere T : VisualLineElementGenerator, IBuiltinElementGenerator, new()\r\n\t\t{\r\n\t\t\tbool hasGenerator = generator != null;\r\n\t\t\tif (hasGenerator != demand) {\r\n\t\t\t\tif (demand) {\r\n\t\t\t\t\tgenerator = new T();\r\n\t\t\t\t\tthis.ElementGenerators.Add(generator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.ElementGenerators.Remove(generator);\r\n\t\t\t\t\tgenerator = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (generator != null)\r\n\t\t\t\tgenerator.FetchOptions(this.Options);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Layers\r\n\t\tinternal readonly TextLayer textLayer;\r\n\t\treadonly LayerCollection layers;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the list of layers displayed in the text view.\r\n\t\t/// </summary>\r\n\t\tpublic UIElementCollection Layers {\r\n\t\t\tget { return layers; }\r\n\t\t}\r\n\r\n\t\tsealed class LayerCollection : UIElementCollection\r\n\t\t{\r\n\t\t\treadonly TextView textView;\r\n\r\n\t\t\tpublic LayerCollection(TextView textView)\r\n\t\t\t\t: base(textView, textView)\r\n\t\t\t{\r\n\t\t\t\tthis.textView = textView;\r\n\t\t\t}\r\n\r\n\t\t\tpublic override void Clear()\r\n\t\t\t{\r\n\t\t\t\tbase.Clear();\r\n\t\t\t\ttextView.LayersChanged();\r\n\t\t\t}\r\n\r\n\t\t\tpublic override int Add(UIElement element)\r\n\t\t\t{\r\n\t\t\t\tint r = base.Add(element);\r\n\t\t\t\ttextView.LayersChanged();\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\r\n\t\t\tpublic override void RemoveAt(int index)\r\n\t\t\t{\r\n\t\t\t\tbase.RemoveAt(index);\r\n\t\t\t\ttextView.LayersChanged();\r\n\t\t\t}\r\n\r\n\t\t\tpublic override void RemoveRange(int index, int count)\r\n\t\t\t{\r\n\t\t\t\tbase.RemoveRange(index, count);\r\n\t\t\t\ttextView.LayersChanged();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid LayersChanged()\r\n\t\t{\r\n\t\t\ttextLayer.index = layers.IndexOf(textLayer);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Inserts a new layer at a position specified relative to an existing layer.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"layer\">The new layer to insert.</param>\r\n\t\t/// <param name=\"referencedLayer\">The existing layer</param>\r\n\t\t/// <param name=\"position\">Specifies whether the layer is inserted above,below, or replaces the referenced layer</param>\r\n\t\tpublic void InsertLayer(UIElement layer, KnownLayer referencedLayer, LayerInsertionPosition position)\r\n\t\t{\r\n\t\t\tif (layer == null)\r\n\t\t\t\tthrow new ArgumentNullException(\"layer\");\r\n\t\t\tif (!Enum.IsDefined(typeof(KnownLayer), referencedLayer))\r\n\t\t\t\tthrow new InvalidEnumArgumentException(\"referencedLayer\", (int)referencedLayer, typeof(KnownLayer));\r\n\t\t\tif (!Enum.IsDefined(typeof(LayerInsertionPosition), position))\r\n\t\t\t\tthrow new InvalidEnumArgumentException(\"position\", (int)position, typeof(LayerInsertionPosition));\r\n\t\t\tif (referencedLayer == KnownLayer.Background && position != LayerInsertionPosition.Above)\r\n\t\t\t\tthrow new InvalidOperationException(\"Cannot replace or insert below the background layer.\");\r\n\r\n\t\t\tLayerPosition newPosition = new LayerPosition(referencedLayer, position);\r\n\t\t\tLayerPosition.SetLayerPosition(layer, newPosition);\r\n\t\t\tfor (int i = 0; i < layers.Count; i++) {\r\n\t\t\t\tLayerPosition p = LayerPosition.GetLayerPosition(layers[i]);\r\n\t\t\t\tif (p != null) {\r\n\t\t\t\t\tif (p.KnownLayer == referencedLayer && p.Position == LayerInsertionPosition.Replace) {\r\n\t\t\t\t\t\t// found the referenced layer\r\n\t\t\t\t\t\tswitch (position) {\r\n\t\t\t\t\t\t\tcase LayerInsertionPosition.Below:\r\n\t\t\t\t\t\t\t\tlayers.Insert(i, layer);\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tcase LayerInsertionPosition.Above:\r\n\t\t\t\t\t\t\t\tlayers.Insert(i + 1, layer);\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\tcase LayerInsertionPosition.Replace:\r\n\t\t\t\t\t\t\t\tlayers[i] = layer;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (p.KnownLayer == referencedLayer && p.Position == LayerInsertionPosition.Above\r\n\t\t\t\t\t\t\t   || p.KnownLayer > referencedLayer) {\r\n\t\t\t\t\t\t// we skipped the insertion position (referenced layer does not exist?)\r\n\t\t\t\t\t\tlayers.Insert(i, layer);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// inserting after all existing layers:\r\n\t\t\tlayers.Add(layer);\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override int VisualChildrenCount {\r\n\t\t\tget { return layers.Count + inlineObjects.Count; }\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override Visual GetVisualChild(int index)\r\n\t\t{\r\n\t\t\tint cut = textLayer.index + 1;\r\n\t\t\tif (index < cut)\r\n\t\t\t\treturn layers[index];\r\n\t\t\telse if (index < cut + inlineObjects.Count)\r\n\t\t\t\treturn inlineObjects[index - cut].Element;\r\n\t\t\telse\r\n\t\t\t\treturn layers[index - inlineObjects.Count];\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override System.Collections.IEnumerator LogicalChildren {\r\n\t\t\tget {\r\n\t\t\t\treturn inlineObjects.Select(io => io.Element).Concat(layers.Cast<UIElement>()).GetEnumerator();\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Inline object handling\r\n\t\tList<InlineObjectRun> inlineObjects = new List<InlineObjectRun>();\r\n\r\n\t\t/// <summary>\r\n\t\t/// Adds a new inline object.\r\n\t\t/// </summary>\r\n\t\tinternal void AddInlineObject(InlineObjectRun inlineObject)\r\n\t\t{\r\n\t\t\tDebug.Assert(inlineObject.VisualLine != null);\r\n\r\n\t\t\t// Remove inline object if its already added, can happen e.g. when recreating textrun for word-wrapping\r\n\t\t\tbool alreadyAdded = false;\r\n\t\t\tfor (int i = 0; i < inlineObjects.Count; i++) {\r\n\t\t\t\tif (inlineObjects[i].Element == inlineObject.Element) {\r\n\t\t\t\t\tRemoveInlineObjectRun(inlineObjects[i], true);\r\n\t\t\t\t\tinlineObjects.RemoveAt(i);\r\n\t\t\t\t\talreadyAdded = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tinlineObjects.Add(inlineObject);\r\n\t\t\tif (!alreadyAdded) {\r\n\t\t\t\tAddVisualChild(inlineObject.Element);\r\n\t\t\t}\r\n\t\t\tinlineObject.Element.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));\r\n\t\t\tinlineObject.desiredSize = inlineObject.Element.DesiredSize;\r\n\t\t}\r\n\r\n\t\tvoid MeasureInlineObjects()\r\n\t\t{\r\n\t\t\t// As part of MeasureOverride(), re-measure the inline objects\r\n\t\t\tforeach (InlineObjectRun inlineObject in inlineObjects) {\r\n\t\t\t\tif (inlineObject.VisualLine.IsDisposed) {\r\n\t\t\t\t\t// Don't re-measure inline objects that are going to be removed anyways.\r\n\t\t\t\t\t// If the inline object will be reused in a different VisualLine, we'll measure it in the AddInlineObject() call.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tinlineObject.Element.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));\r\n\t\t\t\tif (!inlineObject.Element.DesiredSize.IsClose(inlineObject.desiredSize)) {\r\n\t\t\t\t\t// the element changed size -> recreate its parent visual line\r\n\t\t\t\t\tinlineObject.desiredSize = inlineObject.Element.DesiredSize;\r\n\t\t\t\t\tif (allVisualLines.Remove(inlineObject.VisualLine)) {\r\n\t\t\t\t\t\tDisposeVisualLine(inlineObject.VisualLine);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tList<VisualLine> visualLinesWithOutstandingInlineObjects = new List<VisualLine>();\r\n\r\n\t\tvoid RemoveInlineObjects(VisualLine visualLine)\r\n\t\t{\r\n\t\t\t// Delay removing inline objects:\r\n\t\t\t// A document change immediately invalidates affected visual lines, but it does not\r\n\t\t\t// cause an immediate redraw.\r\n\t\t\t// To prevent inline objects from flickering when they are recreated, we delay removing\r\n\t\t\t// inline objects until the next redraw.\r\n\t\t\tif (visualLine.hasInlineObjects) {\r\n\t\t\t\tvisualLinesWithOutstandingInlineObjects.Add(visualLine);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Remove the inline objects that were marked for removal.\r\n\t\t/// </summary>\r\n\t\tvoid RemoveInlineObjectsNow()\r\n\t\t{\r\n\t\t\tif (visualLinesWithOutstandingInlineObjects.Count == 0)\r\n\t\t\t\treturn;\r\n\t\t\tinlineObjects.RemoveAll(\r\n\t\t\t\tior => {\r\n\t\t\t\t\tif (visualLinesWithOutstandingInlineObjects.Contains(ior.VisualLine)) {\r\n\t\t\t\t\t\tRemoveInlineObjectRun(ior, false);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t});\r\n\t\t\tvisualLinesWithOutstandingInlineObjects.Clear();\r\n\t\t}\r\n\r\n\t\t// Remove InlineObjectRun.Element from TextLayer.\r\n\t\t// Caller of RemoveInlineObjectRun will remove it from inlineObjects collection.\r\n\t\tvoid RemoveInlineObjectRun(InlineObjectRun ior, bool keepElement)\r\n\t\t{\r\n\t\t\tif (!keepElement && ior.Element.IsKeyboardFocusWithin) {\r\n\t\t\t\t// When the inline element that has the focus is removed, WPF will reset the\r\n\t\t\t\t// focus to the main window without raising appropriate LostKeyboardFocus events.\r\n\t\t\t\t// To work around this, we manually set focus to the next focusable parent.\r\n\t\t\t\tUIElement element = this;\r\n\t\t\t\twhile (element != null && !element.Focusable) {\r\n\t\t\t\t\telement = VisualTreeHelper.GetParent(element) as UIElement;\r\n\t\t\t\t}\r\n\t\t\t\tif (element != null)\r\n\t\t\t\t\tKeyboard.Focus(element);\r\n\t\t\t}\r\n\t\t\tior.VisualLine = null;\r\n\t\t\tif (!keepElement)\r\n\t\t\t\tRemoveVisualChild(ior.Element);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Brushes\r\n\t\t/// <summary>\r\n\t\t/// NonPrintableCharacterBrush dependency property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty NonPrintableCharacterBrushProperty =\r\n\t\t\tDependencyProperty.Register(\"NonPrintableCharacterBrush\", typeof(Brush), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(Brushes.LightGray));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/sets the Brush used for displaying non-printable characters.\r\n\t\t/// </summary>\r\n\t\tpublic Brush NonPrintableCharacterBrush {\r\n\t\t\tget { return (Brush)GetValue(NonPrintableCharacterBrushProperty); }\r\n\t\t\tset { SetValue(NonPrintableCharacterBrushProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// LinkTextForegroundBrush dependency property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty LinkTextForegroundBrushProperty =\r\n\t\t\tDependencyProperty.Register(\"LinkTextForegroundBrush\", typeof(Brush), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(Brushes.Blue));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/sets the Brush used for displaying link texts.\r\n\t\t/// </summary>\r\n\t\tpublic Brush LinkTextForegroundBrush {\r\n\t\t\tget { return (Brush)GetValue(LinkTextForegroundBrushProperty); }\r\n\t\t\tset { SetValue(LinkTextForegroundBrushProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// LinkTextBackgroundBrush dependency property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty LinkTextBackgroundBrushProperty =\r\n\t\t\tDependencyProperty.Register(\"LinkTextBackgroundBrush\", typeof(Brush), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(Brushes.Transparent));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/sets the Brush used for the background of link texts.\r\n\t\t/// </summary>\r\n\t\tpublic Brush LinkTextBackgroundBrush {\r\n\t\t\tget { return (Brush)GetValue(LinkTextBackgroundBrushProperty); }\r\n\t\t\tset { SetValue(LinkTextBackgroundBrushProperty, value); }\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t/// <summary>\r\n\t\t/// LinkTextUnderlinedBrush dependency property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty LinkTextUnderlineProperty =\r\n\t\t\tDependencyProperty.Register(\"LinkTextUnderline\", typeof(bool), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(true));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/sets whether to underline link texts.\r\n\t\t/// </summary>\r\n\t\t/// <remarks>\r\n\t\t/// Note that when setting this property to false, link text remains clickable and the LinkTextForegroundBrush (if any) is still applied.\r\n\t\t/// Set TextEditorOptions.EnableHyperlinks and EnableEmailHyperlinks to false to disable links completely.\r\n\t\t/// </remarks>\r\n\t\tpublic bool LinkTextUnderline {\r\n\t\t\tget { return (bool)GetValue(LinkTextUnderlineProperty); }\r\n\t\t\tset { SetValue(LinkTextUnderlineProperty, value); }\r\n\t\t}\r\n\r\n\t\t#region Redraw methods / VisualLine invalidation\r\n\t\t/// <summary>\r\n\t\t/// Causes the text editor to regenerate all visual lines.\r\n\t\t/// </summary>\r\n\t\tpublic void Redraw()\r\n\t\t{\r\n\t\t\tRedraw(DispatcherPriority.Normal);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes the text editor to regenerate all visual lines.\r\n\t\t/// </summary>\r\n\t\tpublic void Redraw(DispatcherPriority redrawPriority)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tClearVisualLines();\r\n\t\t\tInvalidateMeasure(redrawPriority);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes the text editor to regenerate the specified visual line.\r\n\t\t/// </summary>\r\n\t\tpublic void Redraw(VisualLine visualLine, DispatcherPriority redrawPriority = DispatcherPriority.Normal)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (allVisualLines.Remove(visualLine)) {\r\n\t\t\t\tDisposeVisualLine(visualLine);\r\n\t\t\t\tInvalidateMeasure(redrawPriority);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes the text editor to redraw all lines overlapping with the specified segment.\r\n\t\t/// </summary>\r\n\t\tpublic void Redraw(int offset, int length, DispatcherPriority redrawPriority = DispatcherPriority.Normal)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tbool changedSomethingBeforeOrInLine = false;\r\n\t\t\tfor (int i = 0; i < allVisualLines.Count; i++) {\r\n\t\t\t\tVisualLine visualLine = allVisualLines[i];\r\n\t\t\t\tint lineStart = visualLine.FirstDocumentLine.Offset;\r\n\t\t\t\tint lineEnd = visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength;\r\n\t\t\t\tif (offset <= lineEnd) {\r\n\t\t\t\t\tchangedSomethingBeforeOrInLine = true;\r\n\t\t\t\t\tif (offset + length >= lineStart) {\r\n\t\t\t\t\t\tallVisualLines.RemoveAt(i--);\r\n\t\t\t\t\t\tDisposeVisualLine(visualLine);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (changedSomethingBeforeOrInLine) {\r\n\t\t\t\t// Repaint not only when something in visible area was changed, but also when anything in front of it\r\n\t\t\t\t// was changed. We might have to redraw the line number margin. Or the highlighting changed.\r\n\t\t\t\t// However, we'll try to reuse the existing VisualLines.\r\n\t\t\t\tInvalidateMeasure(redrawPriority);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes a known layer to redraw.\r\n\t\t/// This method does not invalidate visual lines;\r\n\t\t/// use the <see cref=\"Redraw()\"/> method to do that.\r\n\t\t/// </summary>\r\n\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"knownLayer\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Justification = \"This method is meant to invalidate only a specific layer - I just haven't figured out how to do that, yet.\")]\r\n\t\tpublic void InvalidateLayer(KnownLayer knownLayer)\r\n\t\t{\r\n\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes a known layer to redraw.\r\n\t\t/// This method does not invalidate visual lines;\r\n\t\t/// use the <see cref=\"Redraw()\"/> method to do that.\r\n\t\t/// </summary>\r\n\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"knownLayer\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Justification = \"This method is meant to invalidate only a specific layer - I just haven't figured out how to do that, yet.\")]\r\n\t\tpublic void InvalidateLayer(KnownLayer knownLayer, DispatcherPriority priority)\r\n\t\t{\r\n\t\t\tInvalidateMeasure(priority);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Causes the text editor to redraw all lines overlapping with the specified segment.\r\n\t\t/// Does nothing if segment is null.\r\n\t\t/// </summary>\r\n\t\tpublic void Redraw(ISegment segment, DispatcherPriority redrawPriority = DispatcherPriority.Normal)\r\n\t\t{\r\n\t\t\tif (segment != null) {\r\n\t\t\t\tRedraw(segment.Offset, segment.Length, redrawPriority);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Invalidates all visual lines.\r\n\t\t/// The caller of ClearVisualLines() must also call InvalidateMeasure() to ensure\r\n\t\t/// that the visual lines will be recreated.\r\n\t\t/// </summary>\r\n\t\tvoid ClearVisualLines()\r\n\t\t{\r\n\t\t\tvisibleVisualLines = null;\r\n\t\t\tif (allVisualLines.Count != 0) {\r\n\t\t\t\tforeach (VisualLine visualLine in allVisualLines) {\r\n\t\t\t\t\tDisposeVisualLine(visualLine);\r\n\t\t\t\t}\r\n\t\t\t\tallVisualLines.Clear();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid DisposeVisualLine(VisualLine visualLine)\r\n\t\t{\r\n\t\t\tif (newVisualLines != null && newVisualLines.Contains(visualLine)) {\r\n\t\t\t\tthrow new ArgumentException(\"Cannot dispose visual line because it is in construction!\");\r\n\t\t\t}\r\n\t\t\tvisibleVisualLines = null;\r\n\t\t\tvisualLine.Dispose();\r\n\t\t\tRemoveInlineObjects(visualLine);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region InvalidateMeasure(DispatcherPriority)\r\n\t\tDispatcherOperation invalidateMeasureOperation;\r\n\r\n\t\tvoid InvalidateMeasure(DispatcherPriority priority)\r\n\t\t{\r\n\t\t\tif (priority >= DispatcherPriority.Render) {\r\n\t\t\t\tif (invalidateMeasureOperation != null) {\r\n\t\t\t\t\tinvalidateMeasureOperation.Abort();\r\n\t\t\t\t\tinvalidateMeasureOperation = null;\r\n\t\t\t\t}\r\n\t\t\t\tbase.InvalidateMeasure();\r\n\t\t\t} else {\r\n\t\t\t\tif (invalidateMeasureOperation != null) {\r\n\t\t\t\t\tinvalidateMeasureOperation.Priority = priority;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tinvalidateMeasureOperation = Dispatcher.BeginInvoke(\r\n\t\t\t\t\t\tpriority,\r\n\t\t\t\t\t\tnew Action(\r\n\t\t\t\t\t\t\tdelegate {\r\n\t\t\t\t\t\t\t\tinvalidateMeasureOperation = null;\r\n\t\t\t\t\t\t\t\tbase.InvalidateMeasure();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Get(OrConstruct)VisualLine\r\n\t\t/// <summary>\r\n\t\t/// Gets the visual line that contains the document line with the specified number.\r\n\t\t/// Returns null if the document line is outside the visible range.\r\n\t\t/// </summary>\r\n\t\tpublic VisualLine GetVisualLine(int documentLineNumber)\r\n\t\t{\r\n\t\t\t// TODO: EnsureVisualLines() ?\r\n\t\t\tforeach (VisualLine visualLine in allVisualLines) {\r\n\t\t\t\tDebug.Assert(visualLine.IsDisposed == false);\r\n\t\t\t\tint start = visualLine.FirstDocumentLine.LineNumber;\r\n\t\t\t\tint end = visualLine.LastDocumentLine.LineNumber;\r\n\t\t\t\tif (documentLineNumber >= start && documentLineNumber <= end)\r\n\t\t\t\t\treturn visualLine;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the visual line that contains the document line with the specified number.\r\n\t\t/// If that line is outside the visible range, a new VisualLine for that document line is constructed.\r\n\t\t/// </summary>\r\n\t\tpublic VisualLine GetOrConstructVisualLine(DocumentLine documentLine)\r\n\t\t{\r\n\t\t\tif (documentLine == null)\r\n\t\t\t\tthrow new ArgumentNullException(\"documentLine\");\r\n\t\t\tif (!this.Document.Lines.Contains(documentLine))\r\n\t\t\t\tthrow new InvalidOperationException(\"Line belongs to wrong document\");\r\n\t\t\tVerifyAccess();\r\n\r\n\t\t\tVisualLine l = GetVisualLine(documentLine.LineNumber);\r\n\t\t\tif (l == null) {\r\n\t\t\t\tTextRunProperties globalTextRunProperties = CreateGlobalTextRunProperties();\r\n\t\t\t\tVisualLineTextParagraphProperties paragraphProperties = CreateParagraphProperties(globalTextRunProperties);\r\n\r\n\t\t\t\twhile (heightTree.GetIsCollapsed(documentLine.LineNumber)) {\r\n\t\t\t\t\tdocumentLine = documentLine.PreviousLine;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tl = BuildVisualLine(documentLine,\r\n\t\t\t\t\t\t\t\t\tglobalTextRunProperties, paragraphProperties,\r\n\t\t\t\t\t\t\t\t\telementGenerators.ToArray(), lineTransformers.ToArray(),\r\n\t\t\t\t\t\t\t\t\tlastAvailableSize);\r\n\t\t\t\tallVisualLines.Add(l);\r\n\t\t\t\t// update all visual top values (building the line might have changed visual top of other lines due to word wrapping)\r\n\t\t\t\tforeach (var line in allVisualLines) {\r\n\t\t\t\t\tline.VisualTop = heightTree.GetVisualPosition(line.FirstDocumentLine);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn l;\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Visual Lines (fields and properties)\r\n\t\tList<VisualLine> allVisualLines = new List<VisualLine>();\r\n\t\tReadOnlyCollection<VisualLine> visibleVisualLines;\r\n\t\tdouble clippedPixelsOnTop;\r\n\t\tList<VisualLine> newVisualLines;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the currently visible visual lines.\r\n\t\t/// </summary>\r\n\t\t/// <exception cref=\"VisualLinesInvalidException\">\r\n\t\t/// Gets thrown if there are invalid visual lines when this property is accessed.\r\n\t\t/// You can use the <see cref=\"VisualLinesValid\"/> property to check for this case,\r\n\t\t/// or use the <see cref=\"EnsureVisualLines()\"/> method to force creating the visual lines\r\n\t\t/// when they are invalid.\r\n\t\t/// </exception>\r\n\t\t[System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1065:DoNotRaiseExceptionsInUnexpectedLocations\")]\r\n\t\tpublic ReadOnlyCollection<VisualLine> VisualLines {\r\n\t\t\tget {\r\n\t\t\t\tif (visibleVisualLines == null)\r\n\t\t\t\t\tthrow new VisualLinesInvalidException();\r\n\t\t\t\treturn visibleVisualLines;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets whether the visual lines are valid.\r\n\t\t/// Will return false after a call to Redraw().\r\n\t\t/// Accessing the visual lines property will cause a <see cref=\"VisualLinesInvalidException\"/>\r\n\t\t/// if this property is <c>false</c>.\r\n\t\t/// </summary>\r\n\t\tpublic bool VisualLinesValid {\r\n\t\t\tget { return visibleVisualLines != null; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the TextView is about to be measured and will regenerate its visual lines.\r\n\t\t/// This event may be used to mark visual lines as invalid that would otherwise be reused.\r\n\t\t/// </summary>\r\n\t\tpublic event EventHandler<VisualLineConstructionStartEventArgs> VisualLineConstructionStarting;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the TextView was measured and changed its visual lines.\r\n\t\t/// </summary>\r\n\t\tpublic event EventHandler VisualLinesChanged;\r\n\r\n\t\t/// <summary>\r\n\t\t/// If the visual lines are invalid, creates new visual lines for the visible part\r\n\t\t/// of the document.\r\n\t\t/// If all visual lines are valid, this method does nothing.\r\n\t\t/// </summary>\r\n\t\t/// <exception cref=\"InvalidOperationException\">The visual line build process is already running.\r\n\t\t/// It is not allowed to call this method during the construction of a visual line.</exception>\r\n\t\tpublic void EnsureVisualLines()\r\n\t\t{\r\n\t\t\tDispatcher.VerifyAccess();\r\n\t\t\tif (inMeasure)\r\n\t\t\t\tthrow new InvalidOperationException(\"The visual line build process is already running! Cannot EnsureVisualLines() during Measure!\");\r\n\t\t\tif (!VisualLinesValid) {\r\n\t\t\t\t// increase priority for re-measure\r\n\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\t\t// force immediate re-measure\r\n\t\t\t\tUpdateLayout();\r\n\t\t\t}\r\n\t\t\t// Sometimes we still have invalid lines after UpdateLayout - work around the problem\r\n\t\t\t// by calling MeasureOverride directly.\r\n\t\t\tif (!VisualLinesValid) {\r\n\t\t\t\tDebug.WriteLine(\"UpdateLayout() failed in EnsureVisualLines\");\r\n\t\t\t\tMeasureOverride(lastAvailableSize);\r\n\t\t\t}\r\n\t\t\tif (!VisualLinesValid)\r\n\t\t\t\tthrow new VisualLinesInvalidException(\"Internal error: visual lines invalid after EnsureVisualLines call\");\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Measure\r\n\t\t/// <summary>\r\n\t\t/// Additonal amount that allows horizontal scrolling past the end of the longest line.\r\n\t\t/// This is necessary to ensure the caret always is visible, even when it is at the end of the longest line.\r\n\t\t/// </summary>\r\n\t\tconst double AdditionalHorizontalScrollAmount = 3;\r\n\r\n\t\tSize lastAvailableSize;\r\n\t\tbool inMeasure;\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override Size MeasureOverride(Size availableSize)\r\n\t\t{\r\n\t\t\t// We don't support infinite available width, so we'll limit it to 32000 pixels.\r\n\t\t\tif (availableSize.Width > 32000)\r\n\t\t\t\tavailableSize.Width = 32000;\r\n\r\n\t\t\tif (!canHorizontallyScroll && !availableSize.Width.IsClose(lastAvailableSize.Width))\r\n\t\t\t\tClearVisualLines();\r\n\t\t\tlastAvailableSize = availableSize;\r\n\r\n\t\t\tforeach (UIElement layer in layers) {\r\n\t\t\t\tlayer.Measure(availableSize);\r\n\t\t\t}\r\n\t\t\tMeasureInlineObjects();\r\n\r\n\t\t\tInvalidateVisual(); // = InvalidateArrange+InvalidateRender\r\n\r\n\t\t\tdouble maxWidth;\r\n\t\t\tif (document == null) {\r\n\t\t\t\t// no document -> create empty list of lines\r\n\t\t\t\tallVisualLines = new List<VisualLine>();\r\n\t\t\t\tvisibleVisualLines = allVisualLines.AsReadOnly();\r\n\t\t\t\tmaxWidth = 0;\r\n\t\t\t} else {\r\n\t\t\t\tinMeasure = true;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tmaxWidth = CreateAndMeasureVisualLines(availableSize);\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tinMeasure = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// remove inline objects only at the end, so that inline objects that were re-used are not removed from the editor\r\n\t\t\tRemoveInlineObjectsNow();\r\n\r\n\t\t\tmaxWidth += AdditionalHorizontalScrollAmount;\r\n\t\t\tdouble heightTreeHeight = this.DocumentHeight;\r\n\t\t\tTextEditorOptions options = this.Options;\r\n\t\t\tif (options.AllowScrollBelowDocument) {\r\n\t\t\t\tif (!double.IsInfinity(scrollViewport.Height)) {\r\n\t\t\t\t\t// HACK: we need to keep at least Caret.MinimumDistanceToViewBorder visible so that we don't scroll back up when the user types after\r\n\t\t\t\t\t// scrolling to the very bottom.\r\n\t\t\t\t\tdouble minVisibleDocumentHeight = Math.Max(DefaultLineHeight, Editing.Caret.MinimumDistanceToViewBorder);\r\n\t\t\t\t\t// scrollViewportBottom: bottom of scroll view port, but clamped so that at least minVisibleDocumentHeight of the document stays visible.\r\n\t\t\t\t\tdouble scrollViewportBottom = Math.Min(heightTreeHeight - minVisibleDocumentHeight, scrollOffset.Y) + scrollViewport.Height;\r\n\t\t\t\t\t// increase the extend height to allow scrolling below the document\r\n\t\t\t\t\theightTreeHeight = Math.Max(heightTreeHeight, scrollViewportBottom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttextLayer.SetVisualLines(visibleVisualLines);\r\n\r\n\t\t\tSetScrollData(availableSize,\r\n\t\t\t\t\t\t  new Size(maxWidth, heightTreeHeight),\r\n\t\t\t\t\t\t  scrollOffset);\r\n\t\t\tif (VisualLinesChanged != null)\r\n\t\t\t\tVisualLinesChanged(this, EventArgs.Empty);\r\n\r\n\t\t\treturn new Size(Math.Min(availableSize.Width, maxWidth), Math.Min(availableSize.Height, heightTreeHeight));\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Build all VisualLines in the visible range.\r\n\t\t/// </summary>\r\n\t\t/// <returns>Width the longest line</returns>\r\n\t\tdouble CreateAndMeasureVisualLines(Size availableSize)\r\n\t\t{\r\n\t\t\tTextRunProperties globalTextRunProperties = CreateGlobalTextRunProperties();\r\n\t\t\tVisualLineTextParagraphProperties paragraphProperties = CreateParagraphProperties(globalTextRunProperties);\r\n\r\n\t\t\tDebug.WriteLine(\"Measure availableSize=\" + availableSize + \", scrollOffset=\" + scrollOffset);\r\n\t\t\tvar firstLineInView = heightTree.GetLineByVisualPosition(scrollOffset.Y);\r\n\r\n\t\t\t// number of pixels clipped from the first visual line(s)\r\n\t\t\tclippedPixelsOnTop = scrollOffset.Y - heightTree.GetVisualPosition(firstLineInView);\r\n\t\t\t// clippedPixelsOnTop should be >= 0, except for floating point inaccuracy.\r\n\t\t\tDebug.Assert(clippedPixelsOnTop >= -ExtensionMethods.Epsilon);\r\n\r\n\t\t\tnewVisualLines = new List<VisualLine>();\r\n\r\n\t\t\tif (VisualLineConstructionStarting != null)\r\n\t\t\t\tVisualLineConstructionStarting(this, new VisualLineConstructionStartEventArgs(firstLineInView));\r\n\r\n\t\t\tvar elementGeneratorsArray = elementGenerators.ToArray();\r\n\t\t\tvar lineTransformersArray = lineTransformers.ToArray();\r\n\t\t\tvar nextLine = firstLineInView;\r\n\t\t\tif (heightTree.GetIsCollapsed(nextLine.LineNumber)) {\r\n\t\t\t\tnextLine = null;\t\t\r\n\t\t\t}\r\n\t\t\tdouble maxWidth = 0;\r\n\t\t\tdouble yPos = -clippedPixelsOnTop;\r\n\t\t\twhile (yPos < availableSize.Height && nextLine != null) {\r\n\t\t\t\tVisualLine visualLine = GetVisualLine(nextLine.LineNumber);\r\n\t\t\t\tif (visualLine == null) {\r\n\t\t\t\t\tvisualLine = BuildVisualLine(nextLine,\r\n\t\t\t\t\t\t\t\t\t\t\t\t globalTextRunProperties, paragraphProperties,\r\n\t\t\t\t\t\t\t\t\t\t\t\t elementGeneratorsArray, lineTransformersArray,\r\n\t\t\t\t\t\t\t\t\t\t\t\t availableSize);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvisualLine.VisualTop = scrollOffset.Y + yPos;\r\n\r\n\t\t\t\tnextLine = visualLine.LastDocumentLine.NextLine;\r\n\t\t\t\twhile (nextLine != null && heightTree.GetIsCollapsed(nextLine.LineNumber)) {\r\n\t\t\t\t\tnextLine = nextLine.NextLine;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tyPos += visualLine.Height;\r\n\r\n\t\t\t\tforeach (TextLine textLine in visualLine.TextLines) {\r\n\t\t\t\t\tif (textLine.WidthIncludingTrailingWhitespace > maxWidth)\r\n\t\t\t\t\t\tmaxWidth = textLine.WidthIncludingTrailingWhitespace;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewVisualLines.Add(visualLine);\r\n\t\t\t}\r\n\r\n\t\t\tforeach (VisualLine line in allVisualLines) {\r\n\t\t\t\tDebug.Assert(line.IsDisposed == false);\r\n\t\t\t\tif (!newVisualLines.Contains(line))\r\n\t\t\t\t\tDisposeVisualLine(line);\r\n\t\t\t}\r\n\r\n\t\t\tallVisualLines = newVisualLines;\r\n\t\t\t// visibleVisualLines = readonly copy of visual lines\r\n\t\t\tvisibleVisualLines = new ReadOnlyCollection<VisualLine>(newVisualLines.ToArray());\r\n\t\t\tnewVisualLines = null;\r\n\r\n\t\t\tif (allVisualLines.Any(line => line.IsDisposed)) {\r\n\t\t\t\tthrow new InvalidOperationException(\"A visual line was disposed even though it is still in use.\\n\" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This can happen when Redraw() is called during measure for lines \" +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"that are already constructed.\");\r\n\t\t\t}\r\n\t\t\treturn maxWidth;\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region BuildVisualLine\r\n\t\tTextFormatter formatter;\r\n\t\tinternal TextViewCachedElements cachedElements;\r\n\r\n\t\tTextRunProperties CreateGlobalTextRunProperties()\r\n\t\t{\r\n\t\t\tvar p = new GlobalTextRunProperties();\r\n\t\t\tp.typeface = this.CreateTypeface();\r\n\t\t\tp.fontRenderingEmSize = FontSize;\r\n\t\t\tp.foregroundBrush = (Brush)GetValue(Control.ForegroundProperty);\r\n\t\t\tExtensionMethods.CheckIsFrozen(p.foregroundBrush);\r\n\t\t\tp.cultureInfo = CultureInfo.CurrentCulture;\r\n\t\t\treturn p;\r\n\t\t}\r\n\r\n\t\tVisualLineTextParagraphProperties CreateParagraphProperties(TextRunProperties defaultTextRunProperties)\r\n\t\t{\r\n\t\t\treturn new VisualLineTextParagraphProperties {\r\n\t\t\t\tdefaultTextRunProperties = defaultTextRunProperties,\r\n\t\t\t\ttextWrapping = canHorizontallyScroll ? TextWrapping.NoWrap : TextWrapping.Wrap,\r\n\t\t\t\ttabSize = Options.IndentationSize * WideSpaceWidth,\r\n\t\t\t\tflowDirection = FlowDirection\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tVisualLine BuildVisualLine(DocumentLine documentLine,\r\n\t\t\t\t\t\t\t\t   TextRunProperties globalTextRunProperties,\r\n\t\t\t\t\t\t\t\t   VisualLineTextParagraphProperties paragraphProperties,\r\n\t\t\t\t\t\t\t\t   VisualLineElementGenerator[] elementGeneratorsArray,\r\n\t\t\t\t\t\t\t\t   IVisualLineTransformer[] lineTransformersArray,\r\n\t\t\t\t\t\t\t\t   Size availableSize)\r\n\t\t{\r\n\t\t\tif (heightTree.GetIsCollapsed(documentLine.LineNumber)) {\r\n\r\n\t\t\t\tthrow new InvalidOperationException(\"Trying to build visual line from collapsed line\");\r\n\t\t\t}\r\n\t\t\t\t\r\n\r\n\t\t\t//Debug.WriteLine(\"Building line \" + documentLine.LineNumber);\r\n\r\n\t\t\tVisualLine visualLine = new VisualLine(this, documentLine);\r\n\t\t\tVisualLineTextSource textSource = new VisualLineTextSource(visualLine) {\r\n\t\t\t\tDocument = document,\r\n\t\t\t\tGlobalTextRunProperties = globalTextRunProperties,\r\n\t\t\t\tTextView = this\r\n\t\t\t};\r\n\r\n\t\t\tvisualLine.ConstructVisualElements(textSource, elementGeneratorsArray);\r\n\r\n\t\t\tif (visualLine.FirstDocumentLine != visualLine.LastDocumentLine) {\r\n\t\t\t\t// Check whether the lines are collapsed correctly:\r\n\t\t\t\tdouble firstLinePos = heightTree.GetVisualPosition(visualLine.FirstDocumentLine.NextLine);\r\n\t\t\t\tdouble lastLinePos = heightTree.GetVisualPosition(visualLine.LastDocumentLine.NextLine ?? visualLine.LastDocumentLine);\r\n\t\t\t\tif (!firstLinePos.IsClose(lastLinePos)) {\r\n\t\t\t\t\tfor (int i = visualLine.FirstDocumentLine.LineNumber + 1; i <= visualLine.LastDocumentLine.LineNumber; i++) {\r\n\t\t\t\t\t\tif (!heightTree.GetIsCollapsed(i))\r\n\t\t\t\t\t\t\tthrow new InvalidOperationException(\"Line \" + i + \" was skipped by a VisualLineElementGenerator, but it is not collapsed.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new InvalidOperationException(\"All lines collapsed but visual pos different - height tree inconsistency?\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvisualLine.RunTransformers(textSource, lineTransformersArray);\r\n\r\n\t\t\t// now construct textLines:\r\n\t\t\tint textOffset = 0;\r\n\t\t\tTextLineBreak lastLineBreak = null;\r\n\t\t\tvar textLines = new List<TextLine>();\r\n\t\t\tparagraphProperties.indent = 0;\r\n\t\t\tparagraphProperties.firstLineInParagraph = true;\r\n\t\t\twhile (textOffset <= visualLine.VisualLengthWithEndOfLineMarker) {\r\n\t\t\t\tTextLine textLine = formatter.FormatLine(\r\n\t\t\t\t\ttextSource,\r\n\t\t\t\t\ttextOffset,\r\n\t\t\t\t\tavailableSize.Width,\r\n\t\t\t\t\tparagraphProperties,\r\n\t\t\t\t\tlastLineBreak\r\n\t\t\t\t);\r\n\t\t\t\ttextLines.Add(textLine);\r\n\t\t\t\ttextOffset += textLine.Length;\r\n\r\n\t\t\t\t// exit loop so that we don't do the indentation calculation if there's only a single line\r\n\t\t\t\tif (textOffset >= visualLine.VisualLengthWithEndOfLineMarker)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif (paragraphProperties.firstLineInParagraph) {\r\n\t\t\t\t\tparagraphProperties.firstLineInParagraph = false;\r\n\r\n\t\t\t\t\tTextEditorOptions options = this.Options;\r\n\t\t\t\t\tdouble indentation = 0;\r\n\t\t\t\t\tif (options.InheritWordWrapIndentation) {\r\n\t\t\t\t\t\t// determine indentation for next line:\r\n\t\t\t\t\t\tint indentVisualColumn = GetIndentationVisualColumn(visualLine);\r\n\t\t\t\t\t\tif (indentVisualColumn > 0 && indentVisualColumn < textOffset) {\r\n\t\t\t\t\t\t\tindentation = textLine.GetDistanceFromCharacterHit(new CharacterHit(indentVisualColumn, 0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tindentation += options.WordWrapIndentation;\r\n\t\t\t\t\t// apply the calculated indentation unless it's more than half of the text editor size:\r\n\t\t\t\t\tif (indentation > 0 && indentation * 2 < availableSize.Width)\r\n\t\t\t\t\t\tparagraphProperties.indent = indentation;\r\n\t\t\t\t}\r\n\t\t\t\tlastLineBreak = textLine.GetTextLineBreak();\r\n\t\t\t}\r\n\t\t\tvisualLine.SetTextLines(textLines);\r\n\t\t\theightTree.SetHeight(visualLine.FirstDocumentLine, visualLine.Height);\r\n\t\t\treturn visualLine;\r\n\t\t}\r\n\r\n\t\tstatic int GetIndentationVisualColumn(VisualLine visualLine)\r\n\t\t{\r\n\t\t\tif (visualLine.Elements.Count == 0)\r\n\t\t\t\treturn 0;\r\n\t\t\tint column = 0;\r\n\t\t\tint elementIndex = 0;\r\n\t\t\tVisualLineElement element = visualLine.Elements[elementIndex];\r\n\t\t\twhile (element.IsWhitespace(column)) {\r\n\t\t\t\tcolumn++;\r\n\t\t\t\tif (column == element.VisualColumn + element.VisualLength) {\r\n\t\t\t\t\telementIndex++;\r\n\t\t\t\t\tif (elementIndex == visualLine.Elements.Count)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telement = visualLine.Elements[elementIndex];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn column;\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Arrange\r\n\t\t/// <summary>\r\n\t\t/// Arrange implementation.\r\n\t\t/// </summary>\r\n\t\tprotected override Size ArrangeOverride(Size finalSize)\r\n\t\t{\r\n\t\t\tEnsureVisualLines();\r\n\r\n\t\t\tforeach (UIElement layer in layers) {\r\n\t\t\t\tlayer.Arrange(new Rect(new Point(0, 0), finalSize));\r\n\t\t\t}\r\n\r\n\t\t\tif (document == null || allVisualLines.Count == 0)\r\n\t\t\t\treturn finalSize;\r\n\r\n\t\t\t// validate scroll position\r\n\t\t\tVector newScrollOffset = scrollOffset;\r\n\t\t\tif (scrollOffset.X + finalSize.Width > scrollExtent.Width) {\r\n\t\t\t\tnewScrollOffset.X = Math.Max(0, scrollExtent.Width - finalSize.Width);\r\n\t\t\t}\r\n\t\t\tif (scrollOffset.Y + finalSize.Height > scrollExtent.Height) {\r\n\t\t\t\tnewScrollOffset.Y = Math.Max(0, scrollExtent.Height - finalSize.Height);\r\n\t\t\t}\r\n\t\t\tif (SetScrollData(scrollViewport, scrollExtent, newScrollOffset))\r\n\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\r\n\t\t\t//Debug.WriteLine(\"Arrange finalSize=\" + finalSize + \", scrollOffset=\" + scrollOffset);\r\n\r\n\t\t\t//\t\t\tdouble maxWidth = 0;\r\n\r\n\t\t\tif (visibleVisualLines != null) {\r\n\t\t\t\tPoint pos = new Point(-scrollOffset.X, -clippedPixelsOnTop);\r\n\t\t\t\tforeach (VisualLine visualLine in visibleVisualLines) {\r\n\t\t\t\t\tint offset = 0;\r\n\t\t\t\t\tforeach (TextLine textLine in visualLine.TextLines) {\r\n\t\t\t\t\t\tforeach (var span in textLine.GetTextRunSpans()) {\r\n\t\t\t\t\t\t\tInlineObjectRun inline = span.Value as InlineObjectRun;\r\n\t\t\t\t\t\t\tif (inline != null && inline.VisualLine != null) {\r\n\t\t\t\t\t\t\t\tDebug.Assert(inlineObjects.Contains(inline));\r\n\t\t\t\t\t\t\t\tdouble distance = textLine.GetDistanceFromCharacterHit(new CharacterHit(offset, 0));\r\n\t\t\t\t\t\t\t\tinline.Element.Arrange(new Rect(new Point(pos.X + distance, pos.Y), inline.Element.DesiredSize));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\toffset += span.Length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpos.Y += textLine.Height;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tInvalidateCursorIfMouseWithinTextView();\r\n\r\n\t\t\treturn finalSize;\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Render\r\n\t\treadonly ObserveAddRemoveCollection<IBackgroundRenderer> backgroundRenderers;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the list of background renderers.\r\n\t\t/// </summary>\r\n\t\tpublic IList<IBackgroundRenderer> BackgroundRenderers {\r\n\t\t\tget { return backgroundRenderers; }\r\n\t\t}\r\n\r\n\t\tvoid BackgroundRenderer_Added(IBackgroundRenderer renderer)\r\n\t\t{\r\n\t\t\tConnectToTextView(renderer);\r\n\t\t\tInvalidateLayer(renderer.Layer);\r\n\t\t}\r\n\r\n\t\tvoid BackgroundRenderer_Removed(IBackgroundRenderer renderer)\r\n\t\t{\r\n\t\t\tDisconnectFromTextView(renderer);\r\n\t\t\tInvalidateLayer(renderer.Layer);\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnRenderSizeChanged(SizeChangedInfo sizeInfo)\r\n\t\t{\r\n\t\t\tbase.OnRenderSizeChanged(sizeInfo);\r\n\t\t\tInvalidateLayer(KnownLayer.Selection);\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnRender(DrawingContext drawingContext)\r\n\t\t{\r\n\t\t\tRenderBackground(drawingContext, KnownLayer.Background);\r\n\t\t\tforeach (var line in visibleVisualLines) {\r\n\t\t\t\tBrush currentBrush = null;\r\n\t\t\t\tint startVC = 0;\r\n\t\t\t\tint length = 0;\r\n\t\t\t\tforeach (var element in line.Elements) {\r\n\t\t\t\t\tif (currentBrush == null || !currentBrush.Equals(element.BackgroundBrush)) {\r\n\t\t\t\t\t\tif (currentBrush != null) {\r\n\t\t\t\t\t\t\tBackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();\r\n\t\t\t\t\t\t\tbuilder.AlignToWholePixels = true;\r\n\t\t\t\t\t\t\tbuilder.CornerRadius = 3;\r\n\t\t\t\t\t\t\tforeach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this, line, startVC, startVC + length))\r\n\t\t\t\t\t\t\t\tbuilder.AddRectangle(this, rect);\r\n\t\t\t\t\t\t\tGeometry geometry = builder.CreateGeometry();\r\n\t\t\t\t\t\t\tif (geometry != null) {\r\n\t\t\t\t\t\t\t\tdrawingContext.DrawGeometry(currentBrush, null, geometry);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstartVC = element.VisualColumn;\r\n\t\t\t\t\t\tlength = element.VisualLength;\r\n\t\t\t\t\t\tcurrentBrush = element.BackgroundBrush;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlength += element.VisualLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (currentBrush != null) {\r\n\t\t\t\t\tBackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();\r\n\t\t\t\t\tbuilder.AlignToWholePixels = true;\r\n\t\t\t\t\tbuilder.CornerRadius = 3;\r\n\t\t\t\t\tforeach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this, line, startVC, startVC + length))\r\n\t\t\t\t\t\tbuilder.AddRectangle(this, rect);\r\n\t\t\t\t\tGeometry geometry = builder.CreateGeometry();\r\n\t\t\t\t\tif (geometry != null) {\r\n\t\t\t\t\t\tdrawingContext.DrawGeometry(currentBrush, null, geometry);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tinternal void RenderBackground(DrawingContext drawingContext, KnownLayer layer)\r\n\t\t{\r\n\t\t\tforeach (IBackgroundRenderer bg in backgroundRenderers) {\r\n\t\t\t\tif (bg.Layer == layer) {\r\n\t\t\t\t\tbg.Draw(this, drawingContext);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tinternal void ArrangeTextLayer(IList<VisualLineDrawingVisual> visuals)\r\n\t\t{\r\n\t\t\tPoint pos = new Point(-scrollOffset.X, -clippedPixelsOnTop);\r\n\t\t\tforeach (VisualLineDrawingVisual visual in visuals) {\r\n\t\t\t\tTranslateTransform t = visual.Transform as TranslateTransform;\r\n\t\t\t\tif (t == null || t.X != pos.X || t.Y != pos.Y) {\r\n\t\t\t\t\tvisual.Transform = new TranslateTransform(pos.X, pos.Y);\r\n\t\t\t\t\tvisual.Transform.Freeze();\r\n\t\t\t\t}\r\n\t\t\t\tpos.Y += visual.Height;\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region IScrollInfo implementation\r\n\t\t/// <summary>\r\n\t\t/// Size of the document, in pixels.\r\n\t\t/// </summary>\r\n\t\tSize scrollExtent;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Offset of the scroll position.\r\n\t\t/// </summary>\r\n\t\tVector scrollOffset;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Size of the viewport.\r\n\t\t/// </summary>\r\n\t\tSize scrollViewport;\r\n\r\n\t\tvoid ClearScrollData()\r\n\t\t{\r\n\t\t\tSetScrollData(new Size(), new Size(), new Vector());\r\n\t\t}\r\n\r\n\t\tbool SetScrollData(Size viewport, Size extent, Vector offset)\r\n\t\t{\r\n\t\t\tif (!(viewport.IsClose(this.scrollViewport)\r\n\t\t\t\t  && extent.IsClose(this.scrollExtent)\r\n\t\t\t\t  && offset.IsClose(this.scrollOffset))) {\r\n\t\t\t\tthis.scrollViewport = viewport;\r\n\t\t\t\tthis.scrollExtent = extent;\r\n\t\t\t\tSetScrollOffset(offset);\r\n\t\t\t\tthis.OnScrollChange();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvoid OnScrollChange()\r\n\t\t{\r\n\t\t\tScrollViewer scrollOwner = ((IScrollInfo)this).ScrollOwner;\r\n\t\t\tif (scrollOwner != null) {\r\n\t\t\t\tscrollOwner.InvalidateScrollInfo();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbool canVerticallyScroll;\r\n\t\tbool IScrollInfo.CanVerticallyScroll {\r\n\t\t\tget { return canVerticallyScroll; }\r\n\t\t\tset {\r\n\t\t\t\tif (canVerticallyScroll != value) {\r\n\t\t\t\t\tcanVerticallyScroll = value;\r\n\t\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbool canHorizontallyScroll;\r\n\t\tbool IScrollInfo.CanHorizontallyScroll {\r\n\t\t\tget { return canHorizontallyScroll; }\r\n\t\t\tset {\r\n\t\t\t\tif (canHorizontallyScroll != value) {\r\n\t\t\t\t\tcanHorizontallyScroll = value;\r\n\t\t\t\t\tClearVisualLines();\r\n\t\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdouble IScrollInfo.ExtentWidth {\r\n\t\t\tget { return scrollExtent.Width; }\r\n\t\t}\r\n\r\n\t\tdouble IScrollInfo.ExtentHeight {\r\n\t\t\tget { return scrollExtent.Height; }\r\n\t\t}\r\n\r\n\t\tdouble IScrollInfo.ViewportWidth {\r\n\t\t\tget { return scrollViewport.Width; }\r\n\t\t}\r\n\r\n\t\tdouble IScrollInfo.ViewportHeight {\r\n\t\t\tget { return scrollViewport.Height; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the horizontal scroll offset.\r\n\t\t/// </summary>\r\n\t\tpublic double HorizontalOffset {\r\n\t\t\tget { return scrollOffset.X; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the vertical scroll offset.\r\n\t\t/// </summary>\r\n\t\tpublic double VerticalOffset {\r\n\t\t\tget { return scrollOffset.Y; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the scroll offset;\r\n\t\t/// </summary>\r\n\t\tpublic Vector ScrollOffset {\r\n\t\t\tget { return scrollOffset; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the scroll offset has changed.\r\n\t\t/// </summary>\r\n\t\tpublic event EventHandler ScrollOffsetChanged;\r\n\r\n\t\tvoid SetScrollOffset(Vector vector)\r\n\t\t{\r\n\t\t\tif (!canHorizontallyScroll)\r\n\t\t\t\tvector.X = 0;\r\n\t\t\tif (!canVerticallyScroll)\r\n\t\t\t\tvector.Y = 0;\r\n\r\n\t\t\tif (!scrollOffset.IsClose(vector)) {\r\n\t\t\t\tscrollOffset = vector;\r\n\t\t\t\tif (ScrollOffsetChanged != null)\r\n\t\t\t\t\tScrollOffsetChanged(this, EventArgs.Empty);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tScrollViewer IScrollInfo.ScrollOwner { get; set; }\r\n\r\n\t\tvoid IScrollInfo.LineUp()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(scrollOffset.Y - DefaultLineHeight);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.LineDown()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(scrollOffset.Y + DefaultLineHeight);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.LineLeft()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(scrollOffset.X - WideSpaceWidth);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.LineRight()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(scrollOffset.X + WideSpaceWidth);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.PageUp()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(scrollOffset.Y - scrollViewport.Height);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.PageDown()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(scrollOffset.Y + scrollViewport.Height);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.PageLeft()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(scrollOffset.X - scrollViewport.Width);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.PageRight()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(scrollOffset.X + scrollViewport.Width);\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.MouseWheelUp()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(\r\n\t\t\t\tscrollOffset.Y - (SystemParameters.WheelScrollLines * DefaultLineHeight));\r\n\t\t\tOnScrollChange();\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.MouseWheelDown()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetVerticalOffset(\r\n\t\t\t\tscrollOffset.Y + (SystemParameters.WheelScrollLines * DefaultLineHeight));\r\n\t\t\tOnScrollChange();\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.MouseWheelLeft()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(\r\n\t\t\t\tscrollOffset.X - (SystemParameters.WheelScrollLines * WideSpaceWidth));\r\n\t\t\tOnScrollChange();\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.MouseWheelRight()\r\n\t\t{\r\n\t\t\t((IScrollInfo)this).SetHorizontalOffset(\r\n\t\t\t\tscrollOffset.X + (SystemParameters.WheelScrollLines * WideSpaceWidth));\r\n\t\t\tOnScrollChange();\r\n\t\t}\r\n\r\n\t\tbool defaultTextMetricsValid;\r\n\t\tdouble wideSpaceWidth; // Width of an 'x'. Used as basis for the tab width, and for scrolling.\r\n\t\tdouble defaultLineHeight; // Height of a line containing 'x'. Used for scrolling.\r\n\t\tdouble defaultBaseline; // Baseline of a line containing 'x'. Used for TextTop/TextBottom calculation.\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the width of a 'wide space' (the space width used for calculating the tab size).\r\n\t\t/// </summary>\r\n\t\t/// <remarks>\r\n\t\t/// This is the width of an 'x' in the current font.\r\n\t\t/// We do not measure the width of an actual space as that would lead to tiny tabs in\r\n\t\t/// some proportional fonts.\r\n\t\t/// For monospaced fonts, this property will return the expected value, as 'x' and ' ' have the same width.\r\n\t\t/// </remarks>\r\n\t\tpublic double WideSpaceWidth {\r\n\t\t\tget {\r\n\t\t\t\tCalculateDefaultTextMetrics();\r\n\t\t\t\treturn wideSpaceWidth;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the default line height. This is the height of an empty line or a line containing regular text.\r\n\t\t/// Lines that include formatted text or custom UI elements may have a different line height.\r\n\t\t/// </summary>\r\n\t\tpublic double DefaultLineHeight {\r\n\t\t\tget {\r\n\t\t\t\tCalculateDefaultTextMetrics();\r\n\t\t\t\treturn defaultLineHeight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the default baseline position. This is the difference between <see cref=\"VisualYPosition.TextTop\"/>\r\n\t\t/// and <see cref=\"VisualYPosition.Baseline\"/> for a line containing regular text.\r\n\t\t/// Lines that include formatted text or custom UI elements may have a different baseline.\r\n\t\t/// </summary>\r\n\t\tpublic double DefaultBaseline {\r\n\t\t\tget {\r\n\t\t\t\tCalculateDefaultTextMetrics();\r\n\t\t\t\treturn defaultBaseline;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid InvalidateDefaultTextMetrics()\r\n\t\t{\r\n\t\t\tdefaultTextMetricsValid = false;\r\n\t\t\tif (heightTree != null) {\r\n\t\t\t\t// calculate immediately so that height tree gets updated\r\n\t\t\t\tCalculateDefaultTextMetrics();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid CalculateDefaultTextMetrics()\r\n\t\t{\r\n\t\t\tif (defaultTextMetricsValid)\r\n\t\t\t\treturn;\r\n\t\t\tdefaultTextMetricsValid = true;\r\n\t\t\tif (formatter != null) {\r\n\t\t\t\tvar textRunProperties = CreateGlobalTextRunProperties();\r\n\t\t\t\tusing (var line = formatter.FormatLine(\r\n\t\t\t\t\tnew SimpleTextSource(\"x\", textRunProperties),\r\n\t\t\t\t\t0, 32000,\r\n\t\t\t\t\tnew VisualLineTextParagraphProperties {\r\n\t\t\t\t\t\tdefaultTextRunProperties = textRunProperties,\r\n\t\t\t\t\t\tflowDirection = FlowDirection\r\n\t\t\t\t\t},\r\n\t\t\t\t\tnull)) {\r\n\t\t\t\t\twideSpaceWidth = Math.Max(1, line.WidthIncludingTrailingWhitespace);\r\n\t\t\t\t\tdefaultBaseline = Math.Max(1, line.Baseline);\r\n\t\t\t\t\tdefaultLineHeight = Math.Max(1, line.Height);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\twideSpaceWidth = FontSize / 2;\r\n\t\t\t\tdefaultBaseline = FontSize;\r\n\t\t\t\tdefaultLineHeight = FontSize + 3;\r\n\t\t\t}\r\n\t\t\t// Update heightTree.DefaultLineHeight, if a document is loaded.\r\n\t\t\tif (heightTree != null)\r\n\t\t\t\theightTree.DefaultLineHeight = defaultLineHeight;\r\n\t\t}\r\n\r\n\t\tstatic double ValidateVisualOffset(double offset)\r\n\t\t{\r\n\t\t\tif (double.IsNaN(offset))\r\n\t\t\t\tthrow new ArgumentException(\"offset must not be NaN\");\r\n\t\t\tif (offset < 0)\r\n\t\t\t\treturn 0;\r\n\t\t\telse\r\n\t\t\t\treturn offset;\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.SetHorizontalOffset(double offset)\r\n\t\t{\r\n\t\t\toffset = ValidateVisualOffset(offset);\r\n\t\t\tif (!scrollOffset.X.IsClose(offset)) {\r\n\t\t\t\tSetScrollOffset(new Vector(offset, scrollOffset.Y));\r\n\t\t\t\tInvalidateVisual();\r\n\t\t\t\ttextLayer.InvalidateVisual();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid IScrollInfo.SetVerticalOffset(double offset)\r\n\t\t{\r\n\t\t\toffset = ValidateVisualOffset(offset);\r\n\t\t\tif (!scrollOffset.Y.IsClose(offset)) {\r\n\t\t\t\tSetScrollOffset(new Vector(scrollOffset.X, offset));\r\n\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tRect IScrollInfo.MakeVisible(Visual visual, Rect rectangle)\r\n\t\t{\r\n\t\t\tif (rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf(visual)) {\r\n\t\t\t\treturn Rect.Empty;\r\n\t\t\t}\r\n\t\t\t// Convert rectangle into our coordinate space.\r\n\t\t\tGeneralTransform childTransform = visual.TransformToAncestor(this);\r\n\t\t\trectangle = childTransform.TransformBounds(rectangle);\r\n\r\n\t\t\tMakeVisible(Rect.Offset(rectangle, scrollOffset));\r\n\r\n\t\t\treturn rectangle;\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Scrolls the text view so that the specified rectangle gets visible.\r\n\t\t/// </summary>\r\n\t\tpublic virtual void MakeVisible(Rect rectangle)\r\n\t\t{\r\n\t\t\tRect visibleRectangle = new Rect(scrollOffset.X, scrollOffset.Y,\r\n\t\t\t\t\t\t\t\t\t\t\t scrollViewport.Width, scrollViewport.Height);\r\n\t\t\tVector newScrollOffset = scrollOffset;\r\n\t\t\tif (rectangle.Left < visibleRectangle.Left) {\r\n\t\t\t\tif (rectangle.Right > visibleRectangle.Right) {\r\n\t\t\t\t\tnewScrollOffset.X = rectangle.Left + rectangle.Width / 2;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewScrollOffset.X = rectangle.Left;\r\n\t\t\t\t}\r\n\t\t\t} else if (rectangle.Right > visibleRectangle.Right) {\r\n\t\t\t\tnewScrollOffset.X = rectangle.Right - scrollViewport.Width;\r\n\t\t\t}\r\n\t\t\tif (rectangle.Top < visibleRectangle.Top) {\r\n\t\t\t\tif (rectangle.Bottom > visibleRectangle.Bottom) {\r\n\t\t\t\t\tnewScrollOffset.Y = rectangle.Top + rectangle.Height / 2;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewScrollOffset.Y = rectangle.Top;\r\n\t\t\t\t}\r\n\t\t\t} else if (rectangle.Bottom > visibleRectangle.Bottom) {\r\n\t\t\t\tnewScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;\r\n\t\t\t}\r\n\t\t\tnewScrollOffset.X = ValidateVisualOffset(newScrollOffset.X);\r\n\t\t\tnewScrollOffset.Y = ValidateVisualOffset(newScrollOffset.Y);\r\n\t\t\tif (!scrollOffset.IsClose(newScrollOffset)) {\r\n\t\t\t\tSetScrollOffset(newScrollOffset);\r\n\t\t\t\tthis.OnScrollChange();\r\n\t\t\t\tInvalidateMeasure(DispatcherPriority.Normal);\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Visual element mouse handling\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override HitTestResult HitTestCore(PointHitTestParameters hitTestParameters)\r\n\t\t{\r\n\t\t\t// accept clicks even where the text area draws no background\r\n\t\t\treturn new PointHitTestResult(this, hitTestParameters.HitPoint);\r\n\t\t}\r\n\r\n\t\t[ThreadStatic] static bool invalidCursor;\r\n\r\n\t\t/// <summary>\r\n\t\t/// Updates the mouse cursor by calling <see cref=\"Mouse.UpdateCursor\"/>, but with background priority.\r\n\t\t/// </summary>\r\n\t\tpublic static void InvalidateCursor()\r\n\t\t{\r\n\t\t\tif (!invalidCursor) {\r\n\t\t\t\tinvalidCursor = true;\r\n\t\t\t\tDispatcher.CurrentDispatcher.BeginInvoke(\r\n\t\t\t\t\tDispatcherPriority.Background, // fixes issue #288\r\n\t\t\t\t\tnew Action(\r\n\t\t\t\t\t\tdelegate {\r\n\t\t\t\t\t\t\tinvalidCursor = false;\r\n\t\t\t\t\t\t\tMouse.UpdateCursor();\r\n\t\t\t\t\t\t}));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tinternal void InvalidateCursorIfMouseWithinTextView()\r\n\t\t{\r\n\t\t\t// Don't unnecessarily call Mouse.UpdateCursor() if the mouse is outside the text view.\r\n\t\t\t// Unnecessary updates may cause the mouse pointer to flicker\r\n\t\t\t// (e.g. if it is over a window border, it blinks between Resize and Normal)\r\n\t\t\tif (this.IsMouseOver)\r\n\t\t\t\tInvalidateCursor();\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnQueryCursor(QueryCursorEventArgs e)\r\n\t\t{\r\n\t\t\tVisualLineElement element = GetVisualLineElementFromPosition(e.GetPosition(this) + scrollOffset);\r\n\t\t\tif (element != null) {\r\n\t\t\t\telement.OnQueryCursor(e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnMouseDown(MouseButtonEventArgs e)\r\n\t\t{\r\n\t\t\tbase.OnMouseDown(e);\r\n\t\t\tif (!e.Handled) {\r\n\t\t\t\tEnsureVisualLines();\r\n\t\t\t\tVisualLineElement element = GetVisualLineElementFromPosition(e.GetPosition(this) + scrollOffset);\r\n\t\t\t\tif (element != null) {\r\n\t\t\t\t\telement.OnMouseDown(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnMouseUp(MouseButtonEventArgs e)\r\n\t\t{\r\n\t\t\tbase.OnMouseUp(e);\r\n\t\t\tif (!e.Handled) {\r\n\t\t\t\tEnsureVisualLines();\r\n\t\t\t\tVisualLineElement element = GetVisualLineElementFromPosition(e.GetPosition(this) + scrollOffset);\r\n\t\t\t\tif (element != null) {\r\n\t\t\t\t\telement.OnMouseUp(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Getting elements from Visual Position\r\n\t\t/// <summary>\r\n\t\t/// Gets the visual line at the specified document position (relative to start of document).\r\n\t\t/// Returns null if there is no visual line for the position (e.g. the position is outside the visible\r\n\t\t/// text area).\r\n\t\t/// </summary>\r\n\t\tpublic VisualLine GetVisualLineFromVisualTop(double visualTop)\r\n\t\t{\r\n\t\t\t// TODO: change this method to also work outside the visible range -\r\n\t\t\t// required to make GetPosition work as expected!\r\n\t\t\tEnsureVisualLines();\r\n\t\t\tforeach (VisualLine vl in this.VisualLines) {\r\n\t\t\t\tif (visualTop < vl.VisualTop)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif (visualTop < vl.VisualTop + vl.Height)\r\n\t\t\t\t\treturn vl;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the visual top position (relative to start of document) from a document line number.\r\n\t\t/// </summary>\r\n\t\tpublic double GetVisualTopByDocumentLine(int line)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (heightTree == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\treturn heightTree.GetVisualPosition(heightTree.GetLineByNumber(line));\r\n\t\t}\r\n\r\n\t\tVisualLineElement GetVisualLineElementFromPosition(Point visualPosition)\r\n\t\t{\r\n\t\t\tVisualLine vl = GetVisualLineFromVisualTop(visualPosition.Y);\r\n\t\t\tif (vl != null) {\r\n\t\t\t\tint column = vl.GetVisualColumnFloor(visualPosition);\r\n\t\t\t\t//\t\t\t\tDebug.WriteLine(vl.FirstDocumentLine.LineNumber + \" vc \" + column);\r\n\t\t\t\tforeach (VisualLineElement element in vl.Elements) {\r\n\t\t\t\t\tif (element.VisualColumn + element.VisualLength <= column)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\treturn element;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Visual Position <-> TextViewPosition\r\n\t\t/// <summary>\r\n\t\t/// Gets the visual position from a text view position.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"position\">The text view position.</param>\r\n\t\t/// <param name=\"yPositionMode\">The mode how to retrieve the Y position.</param>\r\n\t\t/// <returns>The position in WPF device-independent pixels relative\r\n\t\t/// to the top left corner of the document.</returns>\r\n\t\tpublic Point GetVisualPosition(TextViewPosition position, VisualYPosition yPositionMode)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (this.Document == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\tDocumentLine documentLine = this.Document.GetLineByNumber(position.Line);\r\n\t\t\tVisualLine visualLine = GetOrConstructVisualLine(documentLine);\r\n\t\t\tint visualColumn = position.VisualColumn;\r\n\t\t\tif (visualColumn < 0) {\r\n\t\t\t\tint offset = documentLine.Offset + position.Column - 1;\r\n\t\t\t\tvisualColumn = visualLine.GetVisualColumn(offset - visualLine.FirstDocumentLine.Offset);\r\n\t\t\t}\r\n\t\t\treturn visualLine.GetVisualPosition(visualColumn, position.IsAtEndOfLine, yPositionMode);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the text view position from the specified visual position.\r\n\t\t/// If the position is within a character, it is rounded to the next character boundary.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"visualPosition\">The position in WPF device-independent pixels relative\r\n\t\t/// to the top left corner of the document.</param>\r\n\t\t/// <returns>The logical position, or null if the position is outside the document.</returns>\r\n\t\tpublic TextViewPosition? GetPosition(Point visualPosition)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (this.Document == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\tVisualLine line = GetVisualLineFromVisualTop(visualPosition.Y);\r\n\t\t\tif (line == null)\r\n\t\t\t\treturn null;\r\n\t\t\treturn line.GetTextViewPosition(visualPosition, Options.EnableVirtualSpace);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the text view position from the specified visual position.\r\n\t\t/// If the position is inside a character, the position in front of the character is returned.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"visualPosition\">The position in WPF device-independent pixels relative\r\n\t\t/// to the top left corner of the document.</param>\r\n\t\t/// <returns>The logical position, or null if the position is outside the document.</returns>\r\n\t\tpublic TextViewPosition? GetPositionFloor(Point visualPosition)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (this.Document == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\tVisualLine line = GetVisualLineFromVisualTop(visualPosition.Y);\r\n\t\t\tif (line == null)\r\n\t\t\t\treturn null;\r\n\t\t\treturn line.GetTextViewPositionFloor(visualPosition, Options.EnableVirtualSpace);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region Service Provider\r\n\t\treadonly ServiceContainer services = new ServiceContainer();\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets a service container used to associate services with the text view.\r\n\t\t/// </summary>\r\n\t\t/// <remarks>\r\n\t\t/// This container does not provide document services -\r\n\t\t/// use <c>TextView.GetService()</c> instead of <c>TextView.Services.GetService()</c> to ensure\r\n\t\t/// that document services can be found as well.\r\n\t\t/// </remarks>\r\n\t\tpublic ServiceContainer Services {\r\n\t\t\tget { return services; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Retrieves a service from the text view.\r\n\t\t/// If the service is not found in the <see cref=\"Services\"/> container,\r\n\t\t/// this method will also look for it in the current document's service provider.\r\n\t\t/// </summary>\r\n\t\tpublic virtual object GetService(Type serviceType)\r\n\t\t{\r\n\t\t\tobject instance = services.GetService(serviceType);\r\n\t\t\tif (instance == null && document != null) {\r\n\t\t\t\tinstance = document.ServiceProvider.GetService(serviceType);\r\n\t\t\t}\r\n\t\t\treturn instance;\r\n\t\t}\r\n\r\n\t\tvoid ConnectToTextView(object obj)\r\n\t\t{\r\n\t\t\tITextViewConnect c = obj as ITextViewConnect;\r\n\t\t\tif (c != null)\r\n\t\t\t\tc.AddToTextView(this);\r\n\t\t}\r\n\r\n\t\tvoid DisconnectFromTextView(object obj)\r\n\t\t{\r\n\t\t\tITextViewConnect c = obj as ITextViewConnect;\r\n\t\t\tif (c != null)\r\n\t\t\t\tc.RemoveFromTextView(this);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t#region MouseHover\r\n\t\t/// <summary>\r\n\t\t/// The PreviewMouseHover event.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly RoutedEvent PreviewMouseHoverEvent =\r\n\t\t\tEventManager.RegisterRoutedEvent(\"PreviewMouseHover\", RoutingStrategy.Tunnel,\r\n\t\t\t\t\t\t\t\t\t\t\t typeof(MouseEventHandler), typeof(TextView));\r\n\t\t/// <summary>\r\n\t\t/// The MouseHover event.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly RoutedEvent MouseHoverEvent =\r\n\t\t\tEventManager.RegisterRoutedEvent(\"MouseHover\", RoutingStrategy.Bubble,\r\n\t\t\t\t\t\t\t\t\t\t\t typeof(MouseEventHandler), typeof(TextView));\r\n\r\n\t\t/// <summary>\r\n\t\t/// The PreviewMouseHoverStopped event.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly RoutedEvent PreviewMouseHoverStoppedEvent =\r\n\t\t\tEventManager.RegisterRoutedEvent(\"PreviewMouseHoverStopped\", RoutingStrategy.Tunnel,\r\n\t\t\t\t\t\t\t\t\t\t\t typeof(MouseEventHandler), typeof(TextView));\r\n\t\t/// <summary>\r\n\t\t/// The MouseHoverStopped event.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly RoutedEvent MouseHoverStoppedEvent =\r\n\t\t\tEventManager.RegisterRoutedEvent(\"MouseHoverStopped\", RoutingStrategy.Bubble,\r\n\t\t\t\t\t\t\t\t\t\t\t typeof(MouseEventHandler), typeof(TextView));\r\n\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the mouse has hovered over a fixed location for some time.\r\n\t\t/// </summary>\r\n\t\tpublic event MouseEventHandler PreviewMouseHover {\r\n\t\t\tadd { AddHandler(PreviewMouseHoverEvent, value); }\r\n\t\t\tremove { RemoveHandler(PreviewMouseHoverEvent, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the mouse has hovered over a fixed location for some time.\r\n\t\t/// </summary>\r\n\t\tpublic event MouseEventHandler MouseHover {\r\n\t\t\tadd { AddHandler(MouseHoverEvent, value); }\r\n\t\t\tremove { RemoveHandler(MouseHoverEvent, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the mouse had previously hovered but now started moving again.\r\n\t\t/// </summary>\r\n\t\tpublic event MouseEventHandler PreviewMouseHoverStopped {\r\n\t\t\tadd { AddHandler(PreviewMouseHoverStoppedEvent, value); }\r\n\t\t\tremove { RemoveHandler(PreviewMouseHoverStoppedEvent, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Occurs when the mouse had previously hovered but now started moving again.\r\n\t\t/// </summary>\r\n\t\tpublic event MouseEventHandler MouseHoverStopped {\r\n\t\t\tadd { AddHandler(MouseHoverStoppedEvent, value); }\r\n\t\t\tremove { RemoveHandler(MouseHoverStoppedEvent, value); }\r\n\t\t}\r\n\r\n\t\tMouseHoverLogic hoverLogic;\r\n\r\n\t\tvoid RaiseHoverEventPair(MouseEventArgs e, RoutedEvent tunnelingEvent, RoutedEvent bubblingEvent)\r\n\t\t{\r\n\t\t\tvar mouseDevice = e.MouseDevice;\r\n\t\t\tvar stylusDevice = e.StylusDevice;\r\n\t\t\tint inputTime = Environment.TickCount;\r\n\t\t\tvar args1 = new MouseEventArgs(mouseDevice, inputTime, stylusDevice) {\r\n\t\t\t\tRoutedEvent = tunnelingEvent,\r\n\t\t\t\tSource = this\r\n\t\t\t};\r\n\t\t\tRaiseEvent(args1);\r\n\t\t\tvar args2 = new MouseEventArgs(mouseDevice, inputTime, stylusDevice) {\r\n\t\t\t\tRoutedEvent = bubblingEvent,\r\n\t\t\t\tSource = this,\r\n\t\t\t\tHandled = args1.Handled\r\n\t\t\t};\r\n\t\t\tRaiseEvent(args2);\r\n\t\t}\r\n\t\t#endregion\r\n\r\n\t\t/// <summary>\r\n\t\t/// Collapses lines for the purpose of scrolling. <see cref=\"DocumentLine\"/>s marked as collapsed will be hidden\r\n\t\t/// and not used to start the generation of a <see cref=\"VisualLine\"/>.\r\n\t\t/// </summary>\r\n\t\t/// <remarks>\r\n\t\t/// This method is meant for <see cref=\"VisualLineElementGenerator\"/>s that cause <see cref=\"VisualLine\"/>s to span\r\n\t\t/// multiple <see cref=\"DocumentLine\"/>s. Do not call it without providing a corresponding\r\n\t\t/// <see cref=\"VisualLineElementGenerator\"/>.\r\n\t\t/// If you want to create collapsible text sections, see <see cref=\"Folding.FoldingManager\"/>.\r\n\t\t/// \r\n\t\t/// Note that if you want a VisualLineElement to span from line N to line M, then you need to collapse only the lines\r\n\t\t/// N+1 to M. Do not collapse line N itself.\r\n\t\t/// \r\n\t\t/// When you no longer need the section to be collapsed, call <see cref=\"CollapsedLineSection.Uncollapse()\"/> on the\r\n\t\t/// <see cref=\"CollapsedLineSection\"/> returned from this method.\r\n\t\t/// </remarks>\r\n\t\tpublic CollapsedLineSection CollapseLines(DocumentLine start, DocumentLine end)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (heightTree == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\treturn heightTree.CollapseText(start, end);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the height of the document.\r\n\t\t/// </summary>\r\n\t\tpublic double DocumentHeight {\r\n\t\t\tget {\r\n\t\t\t\t// return 0 if there is no document = no heightTree\r\n\t\t\t\treturn heightTree != null ? heightTree.TotalHeight : 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the document line at the specified visual position.\r\n\t\t/// </summary>\r\n\t\tpublic DocumentLine GetDocumentLineByVisualTop(double visualTop)\r\n\t\t{\r\n\t\t\tVerifyAccess();\r\n\t\t\tif (heightTree == null)\r\n\t\t\t\tthrow ThrowUtil.NoDocumentAssigned();\r\n\t\t\treturn heightTree.GetLineByVisualPosition(visualTop);\r\n\t\t}\r\n\r\n\t\t/// <inheritdoc/>\r\n\t\tprotected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)\r\n\t\t{\r\n\t\t\tbase.OnPropertyChanged(e);\r\n\t\t\tif (TextFormatterFactory.PropertyChangeAffectsTextFormatter(e.Property)) {\r\n\t\t\t\t// first, create the new text formatter:\r\n\t\t\t\tRecreateTextFormatter();\r\n\t\t\t\t// changing text formatter requires recreating the cached elements\r\n\t\t\t\tRecreateCachedElements();\r\n\t\t\t\t// and we need to re-measure the font metrics:\r\n\t\t\t\tInvalidateDefaultTextMetrics();\r\n\t\t\t} else if (e.Property == Control.ForegroundProperty\r\n\t\t\t\t\t   || e.Property == TextView.NonPrintableCharacterBrushProperty\r\n\t\t\t\t\t   || e.Property == TextView.LinkTextBackgroundBrushProperty\r\n\t\t\t\t\t   || e.Property == TextView.LinkTextForegroundBrushProperty\r\n\t\t\t\t\t   || e.Property == TextView.LinkTextUnderlineProperty) {\r\n\t\t\t\t// changing brushes requires recreating the cached elements\r\n\t\t\t\tRecreateCachedElements();\r\n\t\t\t\tRedraw();\r\n\t\t\t}\r\n\t\t\tif (e.Property == Control.FontFamilyProperty\r\n\t\t\t\t|| e.Property == Control.FontSizeProperty\r\n\t\t\t\t|| e.Property == Control.FontStretchProperty\r\n\t\t\t\t|| e.Property == Control.FontStyleProperty\r\n\t\t\t\t|| e.Property == Control.FontWeightProperty\r\n\t\t\t\t|| e.Property == Control.FlowDirectionProperty) {\r\n\t\t\t\t// changing font properties requires recreating cached elements\r\n\t\t\t\tRecreateCachedElements();\r\n\t\t\t\t// and we need to re-measure the font metrics:\r\n\t\t\t\tInvalidateDefaultTextMetrics();\r\n\t\t\t\tRedraw();\r\n\t\t\t}\r\n\t\t\tif (e.Property == ColumnRulerPenProperty) {\r\n\t\t\t\tcolumnRulerRenderer.SetRuler(this.Options.ColumnRulerPosition, this.ColumnRulerPen);\r\n\t\t\t}\r\n\t\t\tif (e.Property == CurrentLineBorderProperty) {\r\n\t\t\t\tcurrentLineHighlighRenderer.BorderPen = this.CurrentLineBorder;\r\n\t\t\t}\r\n\t\t\tif (e.Property == CurrentLineBackgroundProperty) {\r\n\t\t\t\tcurrentLineHighlighRenderer.BackgroundBrush = this.CurrentLineBackground;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// The pen used to draw the column ruler.\r\n\t\t/// <seealso cref=\"TextEditorOptions.ShowColumnRuler\"/>\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty ColumnRulerPenProperty =\r\n\t\t\tDependencyProperty.Register(\"ColumnRulerPen\", typeof(Pen), typeof(TextView),\r\n\t\t\t\t\t\t\t\t\t\tnew FrameworkPropertyMetadata(CreateFrozenPen(Brushes.LightGray)));\r\n\r\n\t\tstatic Pen CreateFrozenPen(SolidColorBrush brush)\r\n\t\t{\r\n\t\t\tPen pen = new Pen(brush, 1);\r\n\t\t\tpen.Freeze();\r\n\t\t\treturn pen;\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets the pen used to draw the column ruler.\r\n\t\t/// <seealso cref=\"TextEditorOptions.ShowColumnRuler\"/>\r\n\t\t/// </summary>\r\n\t\tpublic Pen ColumnRulerPen {\r\n\t\t\tget { return (Pen)GetValue(ColumnRulerPenProperty); }\r\n\t\t\tset { SetValue(ColumnRulerPenProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// The <see cref=\"CurrentLineBackground\"/> property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty CurrentLineBackgroundProperty =\r\n\t\t\tDependencyProperty.Register(\"CurrentLineBackground\", typeof(Brush), typeof(TextView));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets the background brush used by current line highlighter.\r\n\t\t/// </summary>\r\n\t\tpublic Brush CurrentLineBackground {\r\n\t\t\tget { return (Brush)GetValue(CurrentLineBackgroundProperty); }\r\n\t\t\tset { SetValue(CurrentLineBackgroundProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// The <see cref=\"CurrentLineBorder\"/> property.\r\n\t\t/// </summary>\r\n\t\tpublic static readonly DependencyProperty CurrentLineBorderProperty =\r\n\t\t\tDependencyProperty.Register(\"CurrentLineBorder\", typeof(Pen), typeof(TextView));\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets the background brush used for the current line.\r\n\t\t/// </summary>\r\n\t\tpublic Pen CurrentLineBorder {\r\n\t\t\tget { return (Pen)GetValue(CurrentLineBorderProperty); }\r\n\t\t\tset { SetValue(CurrentLineBorderProperty, value); }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets/Sets highlighted line number.\r\n\t\t/// </summary>\r\n\t\tpublic int HighlightedLine {\r\n\t\t\tget { return this.currentLineHighlighRenderer.Line; }\r\n\t\t\tset { this.currentLineHighlighRenderer.Line = value; }\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Empty line selection width.\r\n\t\t/// </summary>\r\n\t\tpublic virtual double EmptyLineSelectionWidth {\r\n\t\t\tget { return 1; }\r\n\t\t}\r\n\t}\r\n}\r\n";
	}
}
